网络流的残余网络处理，对于跑完最大流之后没有容量的边，判断是否加了容量之后能有增广路，设边从u到v，那就是判断S到u是否有流量和v到T是否有流量

对残余网络进行dfs，然后枚举所有没有容量了的边
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<set>
#include<map>
#include<vector>
#include<queue>
#include<string>
#include<algorithm>
#include<stack>
using namespace std;
void ____(){ ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); }
const int MAXN = 555;
const int INF = 0x3f3f3f3f;
int n, m, rk[MAXN], iter[MAXN], vis[2][MAXN];
#define S 0
#define T n - 1
vector<bool> nrev[MAXN];
struct EDGE{
    int to,cap,rev;
    EDGE(){}
    EDGE(int _to, int _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
    nrev[u].push_back(true);
    nrev[v].push_back(false);
}
bool bfs(){
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));
    queue<int> que;
    que.push(S);
    rk[S] = 1;
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap || rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap || rk[e.to]!=rk[u] + 1) continue;
        int d = dfs(e.to,min(f,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
void search(int u, int tag){
    vis[tag][u] = true;
    for(int i = 0; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!vis[tag][e.to] && (!tag?e.cap:G[e.to][e.rev].cap)) search(e.to,tag);
    }
}
int main(){
    while(scanf("%d %d",&n,&m)!=EOF){
        for(int i = 0; i < n; i++) G[i].clear(), nrev[i].clear();
        for(int i = 1; i <= m; i++){
            int u, v, c;
            scanf("%d %d %d",&u,&v,&c);
            ADDEDGE(u,v,c);
        }
        Dinic();
        memset(vis,0,sizeof(vis));
        search(S,0); search(T,1);
        int cnt = 0;
        for(int i = S; i <= T; i++){
            for(int j = 0; j < (int)G[i].size(); j++){
                EDGE &e = G[i][j];
                if(nrev[i][j]&&!e.cap&&vis[0][i]&&vis[1][e.to]) cnt++;
            }
        }
        printf("%d\n",cnt);
    }
    return 0;
}
```
