建图比较神奇，顾客是按顺序来的，而且开了锁的猪圈之间的猪可以互相转移，所以建边时，如果当前这位顾客选的猪圈之前已经有人开过了，那么之前那位顾客可以向当前这位顾客连
边，因为之前那位顾客选的猪可以从其他的猪圈去选，然后转移到这个选的相同的猪圈。
建边：
建立超级源点和超级汇点
1.源点向各猪圈连边，容量为猪圈容量
2.所有顾客向汇点连边，容量为要买的数量
3.顾客能开的猪圈给向顾客连边，容量INF
4.顾客选的猪圈之前的顾客也选过，之前那个顾客向当前这个顾客连边，容量INF
```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
#define S 0
#define T MAXN-1
const int MAXN = 2222;
const int INF = 0x3f3f3f3f;
int n,m,rk[MAXN],iter[MAXN],last[MAXN];
struct EDGE{
    int to,cap,rev;
    EDGE(){}
    EDGE(int _to, int _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
bool BFS(){
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));
    rk[S] = 1;
    queue<int> que;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap || rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0; 
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap||rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,min(f,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(BFS()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++){
        int cap;
        scanf("%d",&cap);
        ADDEDGE(S,i,cap);
    }
    for(int i = 1; i <= m; i++){
        int k;
        scanf("%d",&k);
        while(k--){
            int fr;
            scanf("%d",&fr);
            ADDEDGE(fr,i+n,INF);
            if(last[fr]) ADDEDGE(last[fr],n+i,INF);
            last[fr] = i+n;
        }
        scanf("%d",&k);
        ADDEDGE(i+n,T,k);
    }
    printf("%d\n",Dinic());
    return 0;
}
```
