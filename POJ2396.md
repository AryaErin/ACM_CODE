网络流，x轴向y轴连边，边权为每个点的上下界差值，源点向每一行连边，边权为行的目标总和减当前各点下界和，每一列向汇点连边，连边方式同行的连边方式，跑最大流
判断是否满流，然后对于x向y轴连的边，流量即为还要加上的值
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
#include<map>
using namespace std;
const int MAXN = 333;
#define S 0
#define T MAXN - 1
const int INF = 0x3f3f3f3f;
struct EDGE{
    int to, cap , rev;
    EDGE(){}
    EDGE(int _to, int _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
int n,m,rsum[MAXN],csum[MAXN],rk[MAXN],iter[MAXN];
int minn[MAXN][MAXN],maxx[MAXN][MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
bool bfs(){
    memset(iter,0,sizeof(iter));
    memset(rk,0,sizeof(rk));
    rk[S] = 1;
    queue<int> que;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap || rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T] != 0;
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap || rk[e.to] != rk[u] + 1) continue;
        int d = dfs(e.to,min(f,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
void solve(){
    scanf("%d %d",&n,&m);
    memset(minn,0,sizeof(minn));
    memset(maxx,INF,sizeof(maxx));
    for(int i = 1; i <= n; i++) scanf("%d",&rsum[i]);
    for(int i = 1; i <= m; i++) scanf("%d",&csum[i]);
    int constrains;
    scanf("%d",&constrains);
    vector<pair<pair<int,int>,int> > vec;
    while(constrains--){
        int r, c, x;
        char op[2];
        scanf("%d %d %s %d",&r,&c,op,&x);
        if(op[0]=='<') vec.push_back(make_pair(make_pair(r,c),x-1));
        else{
            for(int i = (r?r:1); i <= (r?r:n); i++) for(int j = (c?c:1); j <= (c?c:m); j++)
                minn[i][j] = max(minn[i][j],op[0]=='='?x:x+1);
            if(op[0]=='=') vec.push_back(make_pair(make_pair(r,c),x));
        }
    }
    for(int i = 0; i <= n+m; i++) G[i].clear();
    G[T].clear();
    for(int i = 0; i < (int)vec.size(); i++){
        pair<pair<int,int>,int> p = vec[i];
        int r = p.first.first, c = p.first.second, x = p.second;
        for(int i = (r?r:1); i <= (r?r:n); i++) for(int j = (c?c:1); j <= (c?c:m); j++)
            maxx[i][j] = min(maxx[i][j],x);
    }
    for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++){
        if(minn[i][j]>maxx[i][j]) return (void)puts("IMPOSSIBLE\n");
        else if(minn[i][j]<maxx[i][j]) ADDEDGE(i,j+n,maxx[i][j]-minn[i][j]);
    }
    int lftr = 0;
    for(int i = 1; i <= n; i++){
        int tot = 0;
        for(int j = 1; j <= m; j++) tot += minn[i][j];
        if(tot>rsum[i]) return (void)puts("IMPOSSIBLE\n");
        else if(tot<rsum[i]) ADDEDGE(S,i,rsum[i]-tot); 
        lftr += rsum[i] - tot;
    }
    int lftc = 0;
    for(int i = 1; i <= m; i++){
        int tot = 0;
        for(int j = 1; j <= n; j++) tot += minn[j][i];
        if(tot>csum[i]) return (void)puts("IMPOSSIBLE\n");
        else if(tot<csum[i]) ADDEDGE(i+n,T,csum[i]-tot);
        lftc += csum[i] - tot;
    }
    if(lftc!=lftr) return (void)puts("IMPOSSIBLE\n");
    if(Dinic()!=lftc) return (void)puts("IMPOSSIBLE\n");
    //puts("DEBUG IS OK.");
    for(int u = 1; u <= n; u++){
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            int v = e.to - n;
            minn[u][v] += G[e.to][e.rev].cap;
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++) printf("%d ",minn[i][j]);
        puts("");
    }
    puts("");
}
int main(){
    int t; for(scanf("%d",&t); t; t--) solve();
    return 0;
}
```
