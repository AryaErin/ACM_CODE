发现有圈的cell可以向四周连出一条边，无圈的cell可以向四周连出两条边，拆点建图跑二分图匹配即可
```cpp
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 22;
const int dir[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};
int n,m,tot,match[2000];
pair<int,int> node[MAXN][MAXN];
char s[MAXN][MAXN];
bool vis[2000];
vector<int> G[2000];
bool dfs(int u){
    vis[u] = true;
    for(int v : G[u]){
        if(match[v]==-1||(!vis[match[v]]&&dfs(match[v]))){
            match[v] = u;
            return true;
        }
    }
    return false;
}
bool solve(){
    memset(match,255,sizeof(match));
    for(int i = 1; i <= tot; i++){
        memset(vis,false,sizeof(vis));
        if(!dfs(i)) return false;
    }
    return true;
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++) scanf("%s",s[i]+1);
    for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++){
        if(s[i][j]=='o') node[i][j].first = node[i][j].second = ++tot;
        else{
            node[i][j].first = ++tot;
            node[i][j].second = ++tot;
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            for(int d = 0; d < 4; d++){
                int nx = i+dir[d][0];
                int ny = j+dir[d][1];
                if(nx<1||ny<1||nx>n||ny>m) continue;
                G[node[i][j].first].emplace_back(node[nx][ny].first);
                if(node[nx][ny].second!=node[nx][ny].first) G[node[i][j].first].emplace_back(node[nx][ny].second);
                if(node[i][j].second!=node[i][j].first){
                    G[node[i][j].second].emplace_back(node[nx][ny].first);
                    if(node[nx][ny].second!=node[nx][ny].first) G[node[i][j].second].emplace_back(node[nx][ny].second);
                }
            }
        }
    }
    puts(solve()?"Y":"N");
    return 0;
}
```
