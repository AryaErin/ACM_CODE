强连通之后 如果只有一个点了 那就输出no 否则找到没有出边的那个集合即可
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 1e6+7;
int n,m,sccid[MAXN],idx,num,instk[MAXN],dfn[MAXN],low[MAXN],stk[MAXN],top,deg[MAXN];
vector<int> G[MAXN],scc[MAXN];
void tarjan(int u){
    dfn[u] = low[u] = ++idx;
    instk[u] = 1;
    stk[++top] = u;
    for(int v : G[u]){
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u],low[v]);
        }
        else if(instk[v]) low[u] = min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u]){
        int tp;
        num++;
        scc[num].clear();
        do{
            tp = stk[top--];
            sccid[tp] = num;
            scc[num].emplace_back(tp);
            instk[tp] = 0;
        }while(tp!=u);
    }
}
void giao(){
    for(int i = 1; i <= num; i++) deg[i] = 0;
    for(int u = 1; u <= n; u++){
        for(int v : G[u]){
            if(sccid[u]==sccid[v]) continue;
            deg[sccid[u]]++;
        }
    }
}
void solve(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        G[i].clear();
        dfn[i] = low[i] = instk[i] = 0;
    }
    idx = num = top = 0;
    for(int i = 1; i <= m; i++){
        int u, v;
        cin >> u >> v;
        if(u!=v) G[u].emplace_back(v);
    }
    for(int i = 1; i <= n; i++) if(!dfn[i]) tarjan(i);
    if(num==1){
        cout << "NO" << endl;
        return;
    }
    cout << "YES" << endl;
    giao();
    set<int> S;
    for(int i = 1; i <= n; i++) S.insert(i);
    int ID = 0;
    for(int i = 1; i <= num; i++) if(deg[i]==0) ID = i;
    for(int x : scc[ID]) S.erase(x);
    cout << scc[ID].size() << ' ' << S.size() << endl;
    for(int x : scc[ID]) cout << x << ' '; cout << endl;
    for(int x : S) cout << x << ' '; cout << endl;
}
int main(){
    ____();
    int T;
    for(cin >> T; T; T--) solve();
    return 0;
}
```
