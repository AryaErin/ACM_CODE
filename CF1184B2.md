先跑最短路，然后如果飞船能攻击基地，则连边，跑最大匹配，答案要不就是不设障碍，要不就是对每个飞船都设置障碍
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 1111;
using LL = int_fast64_t;
const int INF = 0x3f3f3f3f;
int n,m,s,b,mp[111][111],vis[MAXN],match[MAXN];
vector<int> G[MAXN];
LL g,h;
pair<int,pair<int,int> > sp[MAXN];
pair<int,int> base[MAXN];

bool dfs(int u){
    vis[u] = 1;
    for(int v : G[u]){
        if(match[v]==-1 or (!vis[match[v]] and dfs(match[v]))){
            match[v] = u;
            return true;
        }
    }
    return false;
}
int hungary(){
    int tot = 0;
    memset(match,255,sizeof(match));
    for(int i = 1; i <= s; i++){
        memset(vis,0,sizeof(vis));
        if(dfs(i)) tot++;
    }
    return tot;
}
int main(){
    ____();
    cin >> n >> m;
    memset(mp,0x3f,sizeof(mp));
    for(int i = 1; i <= m; i++){
        int u, v;
        cin >> u >> v;
        mp[u][v] = mp[v][u] = 1;
    }
    for(int i = 1; i <= n; i++) mp[i][i] = 0;
    for(int k = 1; k <= n; k++) for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++)
        mp[i][j] = mp[j][i] = min(mp[i][j],mp[i][k] + mp[k][j]);
    cin >> s >> b >> g >> h;
    for(int i = 1; i <= s; i++) cin >> sp[i].first >> sp[i].second.first >> sp[i].second.second;
    for(int i = 1; i <= b; i++) cin >> base[i].first >> base[i].second;
    for(int i = 1; i <= s; i++) for(int j = 1; j <= b; j++){
        if(sp[i].second.first<base[j].second) continue;
        int p1 = sp[i].first, p2 = base[j].first;
        if(mp[p1][p2]<=sp[i].second.second) G[i].emplace_back(j);
    }
    int tot = hungary();
    cout << min(tot*g,s*h) << endl;
    return 0;
}
```
