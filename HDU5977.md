树分治+SOSDP 高维前缀和
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
typedef long long int LL;
const int MAXN = 5e4+7;
const int N = 10;
LL ret;
int n,k,f[1<<N],g[1<<N],root,sz[MAXN],maxsz[MAXN],col[MAXN];
bool vis[MAXN];
vector<int> G[MAXN];
void findroot(int u, int fa, int tot){
    sz[u] = 1; maxsz[u] = 0;
    for(int v : G[u]){
        if(v==fa or vis[v]) continue;
        findroot(v,u,tot);
        sz[u] += sz[v];
        maxsz[u] = max(maxsz[u],sz[v]);
    }
    maxsz[u] = max(maxsz[u],tot-sz[u]);
    if(maxsz[u]<maxsz[root]) root = u;
}
void search(int u, int fa, int msk){
    f[msk|=col[u]]++;
    for(int v : G[u]){
        if(v==fa or vis[v]) continue;
        search(v,u,msk);
    }
}
void calculate(int u, int msk, LL tag){
    for(int i = 0; i < (1<<k); i++) f[i] = 0;
    search(u,0,msk);
    for(int i = 0; i < (1<<k); i++) g[i] = f[i];
    for(int bit = 0; bit < k; bit++) for(int msk = 0; msk < (1<<k); msk++) if(!(msk&(1<<bit))) g[msk] += g[msk^(1<<bit)];
    for(int msk = 0; msk < (1<<k); msk++) ret += tag * f[msk] * g[((1<<k)-1)^msk];
}
void divide(int u){
    vis[u] = true;
    calculate(u,0,1);
    for(int v : G[u]){
        if(vis[v]) continue;
        calculate(v,col[u],-1);
        root = 0; findroot(v,u,sz[v]);
        divide(root);
    }
}
void solve(){
    for(int i = 1; i <= n; i++) G[i].clear();
    memset(vis,0,sizeof(vis));
    for(int i = 1; i <= n; i++) scanf("%d",&col[i]);
    for(int i = 1; i <= n; i++) col[i] = (1<<(col[i]-1));
    for(int i = 1; i < n; i++){
        int u, v;
        scanf("%d %d",&u,&v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    ret = 0;
    maxsz[0] = MAXN;
    root = 0; findroot(1,0,n);
    divide(root);
    printf("%I64d\n",ret);
}
int main(){
    while(scanf("%d %d",&n,&k)!=EOF) solve();
    return 0;
}
```
