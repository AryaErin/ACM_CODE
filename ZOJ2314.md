无源汇上下界网络流
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 333;
const int MAXM = 1e5+7;
const int INF = 0x3f3f3f3f;
#define S 0
#define T MAXN - 1
int n,m,delta[MAXN],rk[MAXN],iter[MAXN],pipeflow[MAXM];
struct EDGE{
    int to,cap,rev,id;
    EDGE(){}
    EDGE(int to, int cap, int rev, int id):to(to), cap(cap), rev(rev),id(id){}
};
vector<EDGE> G[MAXN];
void ADDEDGE(int u, int v, int cap, int id = 0){
    G[u].push_back(EDGE(v,cap,(int)G[v].size(),0));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1,id));
}
bool bfs(){
    memset(iter,0,sizeof(iter));
    memset(rk,0,sizeof(rk));
    queue<int> que;
    rk[S] = 1;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap or rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int flow){
    if(u==T) return flow;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap or rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,min(e.cap,flow));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
void solve(){
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++) delta[i] = 0;
    for(int i = 0; i <= n; i++) G[i].clear(); G[T].clear();
    for(int i = 1; i <= m; i++){
        int u, v, l, h;
        scanf("%d %d %d %d",&u,&v,&l,&h);
        pipeflow[i] = l;
        delta[u] -= l; delta[v] += l;
        ADDEDGE(u,v,h-l,i);
    }
    int tot = 0;
    for(int i = 1; i <= n; i++){
        if(delta[i]>0) ADDEDGE(S,i,delta[i],0), tot += delta[i];
        else if(delta[i]<0) ADDEDGE(i,T,-delta[i],0);
    }
    if(Dinic()!=tot) puts("NO");
    else{
        puts("YES");
        for(int u = 1; u <= n; u++) for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.id) continue;
            pipeflow[e.id] += e.cap;
        }
        for(int i = 1; i <= m; i++) printf("%d\n",pipeflow[i]);
    }
    
}
int main(){
    int kase;
    for(scanf("%d",&kase); kase; kase--) solve();
    return 0;
}
```
