二分图最小权值覆盖，选取一些点覆盖所有边，要求点权和最小，用最小割做
把每个点拆分成两个点，一个和入边有关，一个和出边有关，每个源点和出点连边，容量为出点的权值，入点和汇点连边，容量为入点权值，最大流就是最小权值
和。最后还要输出最小割的一个割集，考虑从源点开始进行dfs，如果边有容量就继续dfs，最后可以得到哪些点访问过，哪些点没访问过。对于1\~n之间的点（出点），
如果没有访问到，源点到该出点就是一条割边；对于n+1\~2n之间的点（入点），如果访问到了，该入点到汇点就是一条割边。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<set>
#include<queue>
using namespace std;
const int MAXN = 222;
const int INF = 0x3f3f3f3f;
#define S 0
#define T MAXN - 1
struct EDGE{
    int to, cap, rev;
    EDGE(){}
    EDGE(int _to, int _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
vector<int> vec[2];
int n,m,iter[MAXN],rk[MAXN];
bool vis[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
bool bfs(){
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));
    queue<int> que;
    rk[S] = 1;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap || rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap || rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,min(e.cap,f));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
void search(int u){
    vis[u] = true;
    for(int i = 0; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(vis[e.to]||!e.cap) continue;
        search(e.to);
    }
}
int main(){
    while(scanf("%d %d",&n,&m)!=EOF){
        for(int i = 0; i <= n * 2; i++) G[i].clear();
        G[T].clear();
        for(int i = 1; i <= n; i++){
            int c; scanf("%d",&c);
            ADDEDGE(i+n,T,c);
        }
        for(int i = 1; i <= n; i++){
            int c; scanf("%d",&c);
            ADDEDGE(S,i,c);
        }
        for(int i = 1; i <= m; i++){
            int u, v;
            scanf("%d %d",&u,&v);
            ADDEDGE(u,v+n,INF);
        }
        int cost = Dinic();
        vec[0].clear(); vec[1].clear();
        memset(vis,0,sizeof(vis));
        search(S);
        for(int i = 1; i <= n; i++) if(!vis[i]) vec[0].push_back(i);
        for(int i = n+1; i <= 2*n; i++) if(vis[i]) vec[1].push_back(i);
        printf("%d\n%d\n",cost,vec[0].size()+vec[1].size());
        for(int i = 0; i < (int)vec[0].size(); i++) printf("%d -\n",vec[0][i]);
        for(int i = 0; i < (int)vec[1].size(); i++) printf("%d +\n",vec[1][i]-n);
    }
    return 0;
}
```
