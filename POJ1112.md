题目给的是有向边，如果两个点之间不是相互连通的话，就相当于没有边，按处理之后的原图（删去单向边）建补图，原先要找两个团，现在就是要找两个独立集，考虑图
可能被分成好几个联通子图，对于每个子图，要把子图分为两个独立的集合，要求两个集合中，每个集合内的点相互独立，就是把图变成变成二分图，如果不能变成二分图那就没有
答案。接下来我们得到了所有子图所分的两个集合，接下来进行dp把这些集合在分到两个大的集合里让两个集合的大小差值最小即可
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<set>
#include<cmath>
using namespace std;
const int MAXN = 111;
int n,G[MAXN][MAXN],color[MAXN];
set<int> S[MAXN][2];
int f[MAXN][MAXN][MAXN];
bool dfs(int u, int col, int ID){
    color[u] = col;
    S[ID][col-1].insert(u);
    for(int v = 1; v <= n; v++){
        if(!G[u][v]) continue;
        if((color[u]==color[v])||(!color[v]&&!dfs(v,col^3,ID))) return false;
    }
    return true;
}
int main(){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        int v;
        while(scanf("%d",&v) && v) G[i][v] = 1;
        G[i][i] = 1;
    }
    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) G[i][j] = G[j][i] = (G[i][j]&G[j][i]);
    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) G[i][j] ^= 1;
    int ID = 0;
    for(int i = 1; i <= n; i++) if(!color[i]){
        if(!dfs(i,1,++ID)){
            puts("No solution");
            return 0;
        }
    }
    memset(f,255,sizeof(f));
    f[0][0][0] = 0;
    for(int i = 1; i <= ID; i++){
        for(int j = (int)S[i][0].size(); j <= n; j++) for(int k = (int)S[i][1].size(); k <= n; k++){
            if(f[i-1][j-S[i][0].size()][k-S[i][1].size()]!=-1) f[i][j][k] = 0;
        }
        for(int j = (int)S[i][1].size(); j <= n; j++) for(int k = (int)S[i][0].size(); k <= n; k++){
            if(f[i-1][j-S[i][1].size()][k-S[i][0].size()]!=-1) f[i][j][k] = 1;
        }
    }
    set<int> res[2];
    int sza = 0,szb = n;
    for(int i = 1; i <= n-1; i++) if(fabs(szb-sza)>fabs(n-i-i)&&f[ID][i][n-i]!=-1) sza = i, szb = n-i;
    int cur = ID;
    while(cur){
        int sid = f[cur][sza][szb];
        for(set<int>::iterator it = S[cur][sid].begin(); it != S[cur][sid].end(); it++) res[0].insert(*it);
        for(set<int>::iterator it = S[cur][sid^1].begin(); it != S[cur][sid^1].end(); it++) res[1].insert(*it);
        sza -= S[cur][sid].size();
        szb -= S[cur][sid^1].size();
        cur--;
    }
    printf("%d",res[0].size()); for(set<int>::iterator it = res[0].begin(); it != res[0].end(); it++) printf(" %d",*it); puts("");
    printf("%d",res[1].size()); for(set<int>::iterator it = res[1].begin(); it != res[1].end(); it++) printf(" %d",*it); puts("");
    return 0;
}
```
