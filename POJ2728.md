最优比率生成树，二分比率然后重赋边权位c[i][j]-k*d[i][j]，判断最小生成树是否大于等于0
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<set>
#include<map>
#include<cmath>
#include<vector>
#include<queue>
#include<string>
#include<algorithm>
#include<stack>
using namespace std;
const int MAXN = 1e3+7;
const double eps = 1e-5;
int n,vis[MAXN];
pair<pair<int,int>,int> cap[MAXN];
double d[MAXN],dst[MAXN][MAXN],cost[MAXN][MAXN];
double dist(pair<int,int> &A, pair<int,int> &B){
    return sqrt((A.first-B.first)*(A.first-B.first)+(A.second-B.second)*(A.second-B.second));
}
bool check(double k){
    for(int i = 1; i <= n; i++) d[i] = 1e12+7, vis[i] = 0;
    d[1] = 0;
    double tot = 0;
    for(int i = 1; i <= n; i++){
        int pos = 0;
        for(int j = 1; j <= n; j++) if(!vis[j]&&(!pos||d[j]<d[pos])) pos = j;
        if(!pos) break;
        vis[pos] = 1;
        tot += d[pos];
        for(int j = 1; j <= n; j++){
            if(vis[j]) continue;
            d[j] = min(d[j],cost[j][pos]-k*dst[j][pos]);
        }
    }
    return tot >= 0;
}
int main(){
    while(scanf("%d",&n)!=EOF && n){
        for(int i = 1; i <= n; i++) scanf("%d %d %d",&cap[i].first.first,&cap[i].first.second,&cap[i].second);
        for(int i = 1; i <= n; i++) for(int j = i; j <= n; j++){
            dst[i][j] = dst[j][i] = dist(cap[i].first,cap[j].first); 
            cost[i][j] = cost[j][i] = fabs(cap[i].second - cap[j].second);
        }
        double l = 0, r = 40;
        while(r-l>eps){
            double mid = (l + r) / 2;
            if(check(mid)) l = mid;
            else r = mid;
        }
        printf("%.3f\n",l);
    }
    return 0;
}
```
