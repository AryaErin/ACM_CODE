考虑现在有x1,x2,y1,y2(x表示王子，y表示公主)，存在x1->y1 x2->y2,那如果要将x1和y2匹配，同时保证其他剩余的王子和公主依然存在完备匹配，要满足的条件
必然是存在x2->y1的增广路径，也即存在x1->y2->x2->y1->x1这样的环，而环上的y即是环上的x可替换的（前提是x和y有连边）
所以在这张二分图上，所有的王子向喜欢的公主连边，然后在给出的一组完备匹配中，将匹配的公主向王子连边，跑SCC，在同一个强连通分量中的公主是可以被王子选中的，
（王子得要喜欢这个公主）
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<stack>
#include<algorithm>
#include<set>
using namespace std;
const int MAXN = 4444;
int n,dfn[MAXN],idx,num,low[MAXN],sccid[MAXN];
bool instk[MAXN];
struct Graph{
    int tot, head[MAXN], nxt[MAXN*MAXN], to[MAXN*MAXN];
    void Init(){ tot = 0; memset(head,255,sizeof(head)); }
    void ADDEDGE(int u, int v){
        tot++;
        nxt[tot] = head[u];
        to[tot] = v;
        head[u] = tot;
    }
}G;
stack<int> stk;
void tarjan(int u){
    dfn[u] = low[u] = ++idx;
    instk[u] = true;
    stk.push(u);
    for(int i = G.head[u]; ~i; i = G.nxt[i]){
        int v = G.to[i];
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u],low[v]);
        }
        else{
            if(!instk[v]) continue;
            low[u] = min(low[u],dfn[v]);
        }
    }
    if(low[u]==dfn[u]){
        int tp;
        num++;
        do{
            tp = stk.top();
            stk.pop();
            instk[tp] = false;
            sccid[tp] = num;
        }while(tp!=u);
    }
}
int main(){
    while(scanf("%d",&n)!=EOF){
        G.Init();
        for(int i = 1; i <= n; i++){
            int k; scanf("%d",&k);
            while(k--){
                int v; scanf("%d",&v);
                G.ADDEDGE(i,n+v);
            }
        }
        for(int i = 1; i <= n; i++){
            int v; scanf("%d",&v);
            G.ADDEDGE(v+n,i);
        }
        memset(low,0,sizeof(low));
        memset(dfn,0,sizeof(dfn));
        memset(instk,0,sizeof(instk));
        idx = num = 0;
        for(int i = 1; i <= n; i++) if(!dfn[i]) tarjan(i);
        for(int i = 1; i <= n; i++){
            vector<int> vec;
            for(int x = G.head[i]; ~x; x = G.nxt[x]) if(sccid[i]==sccid[G.to[x]]) vec.push_back(G.to[x]);
            printf("%d",vec.size());
            sort(vec.begin(),vec.end());
            for(int i = 0; i < (int)vec.size(); i++) printf(" %d",vec[i]-n);
            puts("");
        }
    }
    return 0;
}
```
