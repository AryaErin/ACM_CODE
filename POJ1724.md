分层图最短路，dist[i][j]表示当前到位置i，花的钱为j的最短路
然后就是标准的Dijkstra了
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
const int MAXN = 111;
const int INF = 0x3f3f3f3f;
int money,n,m,dist[MAXN][MAXN*MAXN];
struct Graph{
    int tot,head[MAXN],to[MAXN*MAXN],nxt[MAXN*MAXN],len[MAXN*MAXN],cst[MAXN*MAXN];
    void init(){ tot = 0; memset(head,255,sizeof(head)); }
    void ADDEDGE(int u, int v, int l, int c){
        tot++;
        to[tot] = v;
        nxt[tot] = head[u];
        len[tot] = l;
        cst[tot] = c;
        head[u] = tot;
    }
}G;
void Dijkstra(){
    memset(dist,INF,sizeof(dist));
    dist[1][0] = 0;
    priority_queue<pair<int,pair<int,int> >,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;
    que.push(make_pair(dist[1][0],make_pair(1,0)));
    while(!que.empty()){
        pair<int,pair<int,int> > tp = que.top();
        que.pop();
        int u = tp.second.first;
        int c = tp.second.second;
        int l = tp.first;
        if(dist[u][c]!=l) continue;
        for(int i = G.head[u]; ~i; i = G.nxt[i]){
            int v = G.to[i];
            int cst = G.cst[i];
            int len = G.len[i];
            if(c+cst>money||dist[v][c+cst]<=dist[u][c]+len) continue;
            dist[v][c+cst] = dist[u][c] + len;
            que.push(make_pair(dist[v][c+cst],make_pair(v,c+cst)));
        }
    }
}
int main(){
    scanf("%d %d %d",&money,&n,&m);
    G.init();
    for(int i = 1; i <= m; i++){
        int u, v, l, c;
        scanf("%d %d %d %d",&u,&v,&l,&c);
        G.ADDEDGE(u,v,l,c);
    }
    Dijkstra();
    int mindist = INF;
    for(int i = 0; i <= money; i++) mindist = min(mindist,dist[n][i]);
    printf("%d\n",mindist);
    return 0;
}
```
