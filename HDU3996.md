最大权闭合图模板
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 5555;
using LL = int_fast64_t;
const LL INF = 0x3f3f3f3f3f3f3f3f;
#define S 0
#define T MAXN - 1

int n,m,id[111][111],cnt,rk[MAXN],iter[MAXN];
LL tot = 0;
struct EDGE{
    int to,rev;
    LL cap;
    EDGE(){}
    EDGE(int _to, LL _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
void ADDEDGE(int u, int v, LL cap){
    G[u].emplace_back(EDGE(v,cap,(int)G[v].size()));
    G[v].emplace_back(EDGE(u,0,(int)G[u].size()-1));
}
bool bfs(){
    memset(iter,0,sizeof(iter));
    memset(rk,0,sizeof(rk));
    rk[S] = 1;
    queue<int> que;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(auto e : G[u]){
            if(!e.cap or rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
LL dfs(int u, LL flow){
    if(u==T) return flow;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        auto &e = G[u][i];
        if(!e.cap or rk[e.to]!=rk[u]+1) continue;
        LL d = dfs(e.to,min(e.cap,flow));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
LL Dinic(){
    LL flow = 0;
    while(bfs()){
        LL d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
void solve(int kase){
    scanf("%d",&m); n = 0; tot = 0;
    for(int i = 0; i < MAXN; i++) G[i].clear();
    for(int i = 1; i <= m; i++){
        int cnt;
        scanf("%d",&cnt);
        for(int j = 1; j <= cnt; j++){
            id[i][j] = ++n;
            LL value, cost; int k;
            scanf("%I64d %I64d %d",&cost,&value,&k);
            value -= cost;
            if(value>0) ADDEDGE(S,id[i][j],value), tot += value;
            else ADDEDGE(id[i][j],T,-value);
            for(int K = 1; K <= k; K++){
                int x, y; scanf("%d %d",&x,&y);
                ADDEDGE(id[i][j],id[x][y],INF);
            }
        }
    }
    printf("Case #%d: %I64d\n",kase,tot - Dinic());
}
int main(){
    int t; scanf("%d",&t);
    for(int kase = 1; kase <= t; kase++) solve(kase);
    return 0;
}
```
