每个串可以看成是一条边，顶点最多26*26个，也就是由两个小写字母组成的各个字符对。然后二分平均长度用SPFA判断正环即可
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<set>
#include<map>
#include<vector>
#include<queue>
#include<string>
#include<algorithm>
#include<stack>
using namespace std;
void ____(){ ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); }
const int MAXN = 1e5+7;
const int MAXM = 26 * 27;
const double eps = 1e-6;
int n,vis[MAXM],inq[MAXM];
vector<pair<int,int> > G[MAXN];
char buf[MAXN];
double d[MAXM];
bool check(double ave){
    for(int i = 0; i < MAXM; i++) inq[i] = d[i] = 0;
    queue<int> que;
    for(int i = 1; i < MAXM; i++){
        que.push(i);
        vis[i] = 1;
    }
    while(!que.empty()){
        int u = que.front();
        que.pop();
        vis[u] = 0;
        for(int i = 0; i < (int)G[u].size(); i++){
            int v = G[u][i].first;
            double dis = G[u][i].second - ave;
            if(d[u]+dis>d[v]){
                d[v] = d[u] + dis;
                if(!vis[v]){
                    vis[v] = 1;
                    if(++inq[v]>13) return true;
                    que.push(v);
                }
            }
        }
    }
    return false;
}
int main(){
    while(scanf("%d",&n)!=EOF && n){
        for(int i = 0; i < MAXM; i++) G[i].clear();
        for(int i = 1; i <= n; i++){
            scanf("%s",buf);
            int len = strlen(buf);
            int u = (buf[0]-'a')*26+buf[1]-'a' + 1;
            int v = (buf[len-2]-'a')*26+buf[len-1]-'a' + 1;
            G[u].push_back(make_pair(v,len));
        }
        double l = 0, r = 1000;
        while(r-l>eps){
            double ave = (l + r) / 2;
            if(check(ave)) l = ave;
            else r = ave;
        }
        if(l==0) puts("No solution.");
        else printf("%.2f\n",l);
    }    
    return 0;
}
```
