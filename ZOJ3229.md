上界限制的网络流

```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 1e4+7;
const int INF = 0x3f3f3f3f;
#define S 0
#define T day + m + 1
#define s day + m + 2
#define t day + m + 3
int day,m,capgirl[MAXN],nodeflow[MAXN],mat[400][1007];
struct EDGE{
    int to, cap, rev;
    EDGE(){}
    EDGE(int to, int cap, int rev):to(to),cap(cap),rev(rev){}
};
vector<EDGE> G[MAXN];
vector<int> vec[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
int rk[MAXN],iter[MAXN];
bool bfs(int st, int ed){
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));;
    queue<int> que;
    que.push(st);
    rk[st] = 1;
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap or rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[ed]!=0;
}
int dfs(int u, int ed, int flow){
    if(u==ed) return flow;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap or rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,ed,min(flow,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(int st, int ed){
    int flow = 0;
    while(bfs(st,ed)){
        int d = dfs(st,ed,INF);
        while(d) flow += d, d = dfs(st,ed,INF);
    }
    return flow;
}
void solve(){
    for(int i = 0; i < MAXN; i++) G[i].clear();
    memset(mat,0,sizeof(mat));
    memset(nodeflow,0,sizeof(nodeflow));
    for(int i = 0; i < MAXN; i++) vec[i].clear();
    int ret = 0;
    for(int i = 1; i <= m; i++){
        scanf("%d",&capgirl[i]);
        nodeflow[day+i] -= capgirl[i];
        nodeflow[T] += capgirl[i];
        ADDEDGE(day+i,T,INF);
    }
    for(int i = 1; i <= day; i++){
        int num, cap;
        scanf("%d %d",&num,&cap);
        vec[i].resize(num);
        ADDEDGE(S,i,cap);
        for(int j = 0; j < num; j++){
            int g, l, h;
            scanf("%d %d %d",&g,&l,&h);
            g++;
            vec[i][j] = g;
            nodeflow[i] -= l; nodeflow[day+g] += l;
            ret += mat[i][g] = l;
            ADDEDGE(i,day+g,h-l);
        }
    }
    int sum = 0;
    for(int i = 1; i <= day + m + 1; i++){
        if(nodeflow[i]>0) sum += nodeflow[i], ADDEDGE(s,i,nodeflow[i]);
        else ADDEDGE(i,t,-nodeflow[i]);
    }
    ADDEDGE(T,S,INF);
    if(Dinic(s,t)!=sum){
        puts("-1"); puts("");
        return;
    }
    G[S].pop_back(); G[T].pop_back();
    Dinic(S,T);
    for(int i = day + 1; i <= day + m; i++){
        for(int j = 0; j < (int)G[i].size(); j++){
            EDGE &e = G[i][j];
            if(e.to < 1 or e.to > day) continue;
            mat[e.to][i-day] += e.cap;
            ret += e.cap;
        }
    }
    printf("%d\n",ret);
    for(int i = 1; i <= day; i++) for(int j = 0; j < (int)vec[i].size(); j++) printf("%d\n",mat[i][vec[i][j]]);
    puts("");
}

int main(){
    while(scanf("%d %d",&day,&m)!=EOF) solve();
    return 0;
}
```
