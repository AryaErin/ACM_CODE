
BFS里套DFS

```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 2e5+7;
int n,m;
struct Graph{
    int head[MAXN], to[MAXN<<2], nxt[MAXN<<2], w[MAXN<<2], tot;
    void clear(){
        tot = 0;
        memset(head,255,sizeof(head));
    }
    void ADDEDGE(int u, int v, int ww){
        to[tot] = v; nxt[tot] = head[u];
        w[tot] = ww; head[u] = tot++;
    }
}G;
bool vis[MAXN<<1];
void dfs(int u, int w, int step, queue<pair<int,int> > &que){
    que.push(make_pair(u,step));
    for(int i = G.head[u]; ~i; i = G.nxt[i]){
        int v = G.to[i], ww = G.w[i];
        if(vis[i] or ww!=w) continue;
        vis[i] = vis[i^1] = true;
        dfs(v,w,step,que);
    }
}
void bfs(){
    memset(vis,0,sizeof(vis));
    queue<pair<int,int> > que;
    que.push(make_pair(1,0));
    vis[1] = true;
    while(!que.empty()){
        auto p = que.front();
        que.pop();
        int u = p.first, step = p.second;
        if(u==n){
            printf("%d\n",step);
            return;
        }
        for(int i = G.head[u]; ~i; i = G.nxt[i]){
            int v = G.to[i], w = G.w[i];
            if(vis[i]) continue;
            vis[i] = vis[i^1] = true;
            dfs(v,w,step+1,que);
        }
    }
    puts("-1");
}
void solve(){
    G.clear();
    for(int i = 1; i <= m; i++){
        int u, v, w;
        scanf("%d %d %d",&u,&v,&w);
        G.ADDEDGE(u,v,w);
        G.ADDEDGE(v,u,w);
    }
    bfs();
}
int main(){
    while(scanf("%d %d",&n,&m)!=EOF) solve();
    return 0;
}
```
