混合欧拉回路
1.先把无向边随意定向，然后对每个点判断入度+出度是否是奇数，如果是奇数就不可能存在欧拉回路
2.建源点和汇点，所有出度>入度的点从源点连一条边，容量为(出度-入度)/2，所有入度>出度的点向汇点连一条边，容量为(入度-出度)/2
3.然后跑最大流是否满流

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
const int MAXN = 1111;
#define S 0
#define T MAXN-1
const int INF = 0x3f3f3f3f;
int KASE,n,m,totflow,ind[MAXN],outd[MAXN],decnt,rk[MAXN],iter[MAXN];
pair<int,int> E[MAXN];
struct EDGE{
    int to, cap, rev;
    EDGE(){}
    EDGE(int _to, int _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
bool bfs(){
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));
    rk[S] = 1;
    queue<int> que;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap||rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap || rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,min(e.cap,f));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
bool Dinic(){
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow >= totflow;
}
void solve(){
    scanf("%d %d",&n,&m);
    decnt = totflow = 0;
    for(int i = 0; i < MAXN; i++) G[i].clear();
    memset(ind,0,sizeof(ind));
    memset(outd,0,sizeof(outd));
    for(int i = 1; i <= m; i++){
        int u, v, op;
        scanf("%d %d %d",&u,&v,&op);
        if(!op) E[++decnt] = make_pair(u,v);
        ind[v]++; outd[u]++;
    }
    for(int i = 1; i <= n; i++) if((ind[i]+outd[i])&1){
        puts("impossible");
        return;
    }
    for(int i = 1; i <= n; i++){
        if(outd[i]-ind[i]>0) ADDEDGE(S,i,(outd[i]-ind[i])/2), totflow += (outd[i]-ind[i])/2;
        if(ind[i]-outd[i]>0) ADDEDGE(i,T,(ind[i]-outd[i])/2);
    }
    for(int i = 1; i <= decnt; i++) ADDEDGE(E[i].first,E[i].second,1);
    if(Dinic()) puts("possible");
    else puts("impossible");
}
int main(){
    for(scanf("%d",&KASE); KASE; KASE--) solve();
    return 0;
}
```
