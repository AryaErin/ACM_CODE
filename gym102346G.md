乘法变成对数加法就是KM匹配的板子了
```cpp
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 111;
const int INF = 0x3f3f3f3f;
int n,LX[MAXN],LY[MAXN],visx[MAXN],visy[MAXN],match[MAXN],slack[MAXN],G[MAXN][MAXN];
bool dfs(int x){
    visx[x] = 1;
    for(int y = 1; y <= n; y++){
        if(visy[y]) continue;
        int gap = LX[x] + LY[y] - G[x][y];
        if(!gap){
            visy[y] = 1;
            if(match[y]==-1||(!visx[match[y]]&&dfs(match[y]))){
                match[y] = x;
                return true;
            }
        }
        else slack[y] = min(slack[y],gap);
    }
    return false;
}
void KM_match(){
    memset(match,255,sizeof(match));
    for(int i = 1; i <= n; i++) LX[i] = *max_element(G[i]+1,G[i]+1+n);
    memset(LY,0,sizeof(LY));
    for(int i = 1; i <= n; i++){
        memset(slack,INF,sizeof(slack));
        while(true){
            memset(visx,0,sizeof(visx));
            memset(visy,0,sizeof(visy));
            if(dfs(i)) break;
            int d = INF;
            for(int j = 1; j <= n; j++) if(!visy[j]) d = min(d,slack[j]);
            for(int j = 1; j <= n; j++) if(visx[j]) LX[j]-=d;
            for(int j = 1; j <= n ;j++) if(visy[j]) LY[j]+=d;
            else slack[j]-=d;
        }
    }
    for(int i = 1; i <= n; i++) printf("%d ",match[i]);
}
int main(){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){
        scanf("%d",&G[i][j]);
        G[i][j] = log(G[i][j])*1000000;
    }
    KM_match();
    puts("");
    return 0;
}

```
