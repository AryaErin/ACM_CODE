有源汇上下界最小流

二分 t -> s 的流量 判断是否有循环流的可行流
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 222;
const int INF = 0x3f3f3f3f;
// const int MAXM = 4e4+7;
#define S 0
#define T MAXN - 1
#define s n + 1
#define t n + 2
int n,ind[MAXN],outd[MAXN],nodeflow[MAXN];
struct EDGE{
    int to, cap, rev;
    EDGE(){}
    EDGE(int to, int cap, int rev):to(to),cap(cap),rev(rev){}
};
vector<EDGE> G[MAXN];
vector<int> GG[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
int rk[MAXN],iter[MAXN];
bool bfs(){
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));
    queue<int> que;
    que.push(S);
    rk[S] = 1;
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap or rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int flow){
    if(u==T) return flow;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap or rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,min(flow,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d) flow += d, d = dfs(S,INF);
    }
    return flow;
}
bool check(int m){
    for(int i = 0; i <= n + 2; i++) G[i].clear();
    G[T].clear();
    for(int u = 1; u <= n; u++){
        if(!ind[u]) ADDEDGE(s,u,INF);
        if(!outd[u]) ADDEDGE(u,t,INF);
        for(int i = 0; i < (int)GG[u].size(); i++) ADDEDGE(u,GG[u][i],INF);
    }
    ADDEDGE(t,s,m);
    int tot = 0;
    for(int u = 1; u <= n; u++){
        if(nodeflow[u]>0) tot += nodeflow[u], ADDEDGE(S,u,nodeflow[u]);
        else if(nodeflow[u]<0) ADDEDGE(u,T,-nodeflow[u]);
    }
    return Dinic()==tot;
}
int main(){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        int sz; scanf("%d",&sz);
        GG[i].resize(sz);
        outd[i] = sz;
        for(int j = 0; j < sz; j++){
            scanf("%d",&GG[i][j]);
            ind[GG[i][j]]++;
        }
    }
    for(int i = 1; i <= n; i++) nodeflow[i] = 0;
    for(int u = 1; u <= n; u++) for(int i = 0; i < (int)GG[u].size(); i++){
        nodeflow[u]--;
        nodeflow[GG[u][i]]++;
    }
    int l = 1, r = n*n;
    while(l<=r){
        int mid = (l + r) >> 1;
        if(check(mid)) r = mid - 1;
        else l = mid + 1;
    }
    printf("%d\n",l);
    return 0;
}
```
