虚树模板
```cpp
//#pragma comment(linker, "/STACK:1024000000,1024000000")
//#pragma GCC optimize("O3")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 5e5+7;
using LL = int_fast64_t;
int n,Q,m,dfn[MAXN],idx,sz[MAXN],par[MAXN][20],depth[MAXN];
LL cost[MAXN][20],f[MAXN];
set<int> S,imp;
vector<pair<int,LL>> G[MAXN];
vector<int> vec;
void dfs1(int u, int ff){
    depth[u] = depth[ff] + 1;
    dfn[u] = ++idx;
    sz[u] = 1;
    for(int i = 1; par[u][i-1]; i++) par[u][i] = par[par[u][i-1]][i-1];
    for(int i = 1; par[u][i-1]; i++) cost[u][i] = min(cost[u][i-1],cost[par[u][i-1]][i-1]);
    for(auto e : G[u]){
        int v = e.first;
        if(v==ff) continue;
        cost[v][0] = e.second;
        par[v][0] = u;
        dfs1(v,u);
        sz[u] += sz[v];
    }
}
int LCA(int u, int v){
    if(depth[u]<depth[v]) swap(u,v);
    for(int i = 0; depth[u] - depth[v]; i++) if((depth[u]-depth[v])&(1<<i)) u = par[u][i];
    if(u==v) return u;
    for(int i = 19; i >= 0; i--) if(par[u][i]!=par[v][i]){
        u = par[u][i];
        v = par[v][i];
    }
    return par[u][0];
}
LL dist(int u, int v){
    if(depth[u]<depth[v]) swap(u,v);
    LL minn = 0x3f3f3f3f;
    for(int i = 0; depth[u] - depth[v]; i++) if((depth[u]-depth[v])&(1<<i)){
        minn = min(minn,cost[u][i]);
        u = par[u][i];
    }
    return minn;
}
void dfs2(int R, int &ptr, int ff, const int cap){
    while(ptr<cap&&dfn[vec[ptr]]<=R){
        int u = vec[ptr];
        G[ff].emplace_back(u,dist(u,ff));
        int NR = dfn[u] + sz[u] - 1;
        ptr++;
        dfs2(NR,ptr,u,cap);
    }
}
void solve(int u){
    f[u] = 0;
    for(auto e : G[u]){
        int v = e.first;
        LL w = e.second;
        solve(v);
        if(imp.count(v)) f[u] += w;
        else f[u] += min(w,f[v]);
    }
}
int main(){
    scanf("%d",&n);
    for(int i = 1; i < n; i++){
        int u, v, w;
        scanf("%d %d %d",&u,&v,&w);
        G[u].emplace_back(make_pair(v,w));
        G[v].emplace_back(make_pair(u,w));
    }
    dfs1(1,0);
    scanf("%d",&Q);
    while(Q--){
        scanf("%d",&m);
        vec.resize(m);
        for(int i = 0; i < m; i++) scanf("%d",&vec[i]);
        sort(vec.begin(),vec.end(),[](const int &A, const int &B){ return dfn[A] < dfn[B]; });
        S.clear();
        imp.clear();
        for(int i = 0; i < m; i++){
            S.insert(vec[i]);
            imp.insert(vec[i]);
        }
        for(int i = 0; i < m - 1; i++){
            int lca = LCA(vec[i],vec[i+1]);
            if(!S.count(lca)){
                S.insert(lca);
                vec.emplace_back(lca);
            }
        }
        if(!S.count(1)) vec.emplace_back(1);
        sort(vec.begin(),vec.end(),[](const int &A, const int &B){ return dfn[A] < dfn[B]; });
        int ptr = 1;
        for(int u : vec) G[u].clear();
        dfs2(n,ptr,1,vec.size());
        solve(1);
        printf("%lld\n",f[1]);
    }
    return 0;
}
```
