欧拉回路+模拟栈

这里的边其实就是前n-1个数字向最后一个数字之间连的边
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<stack>
#include<algorithm>
#include<cmath>
using namespace std;
const int MAXN = 1e5+7;
int G[MAXN][10],n,top,MOD;
char stk[MAXN*10];
pair<pair<int,int>,int> STACK[MAXN*10];
int TOP;
void dfs(){
    STACK[++TOP] = make_pair(make_pair(0,-1),0);
    while(TOP){
        int u = STACK[TOP].first.first;
        int last = STACK[TOP].first.second;
        int &i = STACK[TOP].second;
        while(i < 10){
            if(!G[u][i]){
                i++;
                continue;
            }
            G[u][i] = 0;
            STACK[++TOP] = make_pair(make_pair((u*10+i)%MOD,i),0);
            break;
        }
        if(i==10){
            if(last!=-1) stk[++top] = last+'0';
            TOP--;
        }
        else i++;
    }
}
void solve(){
    top = TOP = 0;
    MOD = 1;
    for(int i = 1; i < n; i++) MOD*=10;
    for(int i = 0; i < MOD; i++) for(int j = 0; j < 10; j++) G[i][j] = 1;
    dfs();
    for(int i = 1; i < n; i++) putchar('0');
    reverse(stk+1,stk+1+top);
    stk[++top] = '\0';
    puts(stk+1);
}
int main(){
    while(scanf("%d",&n) && n) solve();
    return 0;
}
```
