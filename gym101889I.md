最小生成树，树上倍增+LCA维护最小生成树路径上最大边，替换即可
```cpp
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 1e5+7;
int n,m,q,depth[MAXN],par[MAXN][20],maxdist[MAXN][20],root[MAXN],tot;
map<pair<int,int>,int> edge;
vector<pair<int,pair<int,int>>> vec;
vector<pair<int,int>> G[MAXN];
int findroot(int u){
    if(u!=root[u]) root[u] = findroot(root[u]);
    return root[u];
}
int LCA(int u, int v){
    if(depth[u]<depth[v]) swap(u,v);
    for(int i = 0; i < 20; i++) if((depth[u]-depth[v])&(1<<i)) u = par[u][i];
    if(u==v) return u;
    for(int i = 19; i >= 0; i--) if(par[u][i]!=par[v][i]){
        u = par[u][i];
        v = par[v][i];
    }
    return par[u][0];
}
int getmaxdist(int u, int v){
    int maxx = 0;
    int lca = LCA(u,v);
    int dep = depth[lca] + 1;
    for(int i = 0; dep<depth[u]; i++) if((dep-depth[u])&(1<<i)){
        maxx = max(maxx,maxdist[u][i]);
        u = par[u][i];
    }
    for(int i = 0; dep<depth[v]; i++) if((dep-depth[v])&(1<<i)){
        maxx = max(maxx,maxdist[v][i]);
        v = par[v][i];
    }
    if(dep==depth[u]) maxx = max(maxx,maxdist[u][0]);
    if(dep==depth[v]) maxx = max(maxx,maxdist[v][0]);
    return maxx;
}
void dfs(int u, int f){
    depth[u] = depth[f] + 1;
    for(int i = 1; par[u][i-1]; i++){
        par[u][i] = par[par[u][i-1]][i-1];
        maxdist[u][i] = max(maxdist[u][i-1],maxdist[par[u][i-1]][i-1]);
    }
    for(auto e : G[u]){
        int v = e.first;
        if(v==f) continue;
        par[v][0] = u;
        maxdist[v][0] = e.second;
        dfs(v,u);
    }
}
int main(){
    scanf("%d %d",&n,&m);
    vec.resize(m);
    for(int i = 0; i < m; i++){
        scanf("%d %d %d",&vec[i].second.first,&vec[i].second.second,&vec[i].first);
        if(vec[i].second.first>vec[i].second.second) swap(vec[i].second.first,vec[i].second.second);
        edge.insert(make_pair(vec[i].second,vec[i].first));
    }
    sort(vec.begin(),vec.end());
    for(int i = 1; i <= n; i++) root[i] = i;
    for(int i = 0; i < m; i++){
        int u = vec[i].second.first;
        int v = vec[i].second.second;
        if(findroot(u)==findroot(v)) continue;
        G[u].emplace_back(make_pair(v,vec[i].first));
        G[v].emplace_back(make_pair(u,vec[i].first));
        root[findroot(u)] = findroot(v);
        tot += vec[i].first;
    }
    dfs(1,0);
    scanf("%d",&q);
    for(int i = 1; i <= q; i++){
        int u, v;
        scanf("%d %d",&u,&v);
        if(u>v) swap(u,v);
        printf("%d\n",tot+edge.at(make_pair(u,v))-getmaxdist(u,v));
    }
    return 0;
}
```
