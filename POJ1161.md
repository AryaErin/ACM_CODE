每个member可以视为在好几个区域，从各个member到这些城镇的距离为0，然后对各个区域建图，有相邻边的区域的距离为1，建图完之后floyd，找到最优区域即可
```cpp
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#include<iostream>
#include<map>
#include<set>
using namespace std;
const int MAXN = 333;
const int INF = 0x3f3f3f3f;
int n,m,mem,member[MAXN],G[MAXN][MAXN],adj[MAXN][MAXN];
int buf[MAXN];
set<int> S[MAXN];
int main(){
    scanf("%d %d %d",&m,&n,&mem);
    for(int i = 1; i <= mem; i++) scanf("%d",&member[i]);
    memset(G,0x3f,sizeof(G));
    for(int i = 1; i <= m; i++){
        int k; scanf("%d",&k);
        for(int j = 0; j < k; j++){
            scanf("%d",&buf[j]);
            S[buf[j]].insert(i);
        }
        for(int j = 0; j < k; j++){
            int x = buf[j], y = buf[(j+1)%k];
            if(x>y) x^=y^=x^=y;
            if(adj[x][y]) G[i][adj[x][y]] = G[adj[x][y]][i] = 1;
            else adj[x][y] = i;
        }
        G[i][i] = 0;
    }
    for(int k = 1; k <= m; k++) for(int i = 1; i <= m; i++) for(int j = i + 1; j <= m; j++){
        G[i][j] = G[j][i] = min(G[i][j],G[i][k]+G[k][j]);
    }
    int res = INF;
    for(int i = 1; i <= m; i++){
        int cres = 0;
        for(int j = 1; j <= mem; j++){
            int minn = INF;
            for(set<int>::iterator it = S[member[j]].begin(); it != S[member[j]].end(); it++) minn = min(minn,G[i][*it]);
            if(minn==INF){
                cres = INF;
                break;
            }
            cres += minn;
        }
        res = min(res,cres);
    }
    printf("%d\n",res);
    return 0;
}
```
