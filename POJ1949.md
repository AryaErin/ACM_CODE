已经是拓扑序了，所以按顺序找最长路即可
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int MAXN = 1e4+7;
vector<int> pre[MAXN];
int n,cost[MAXN],dist[MAXN];
int main(){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d",&cost[i]);
        int k; scanf("%d",&k);
        while(k--){
            int fr; scanf("%d",&fr);
            pre[i].push_back(fr);
        }
    }
    for(int i = 1; i <= n; i++) dist[i] = cost[i];
    for(int i = 2; i <= n; i++){
        for(int j = 0; j < (int)pre[i].size(); j++){
            int p = pre[i][j];
            dist[i] = max(dist[i],dist[p]+cost[i]);
        }
    }
    printf("%d\n",*max_element(dist+1,dist+1+n));
    return 0;
}
```
