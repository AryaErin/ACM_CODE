反过来考虑，相当于不断加点
左部图从0~n，右部图为club，对于每次加进去一个学生，左部代表学生的能力值，和右部，学生所在的club连边，不断增广即可
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 5555;
int n,m,match[MAXN],vis[MAXN],ret[MAXN],q,Q[MAXN],cur;
pair<int,int> pr[MAXN];
vector<int> G[MAXN];
set<int> S;
bool dfs(int u){
    vis[u] = true;
    for(int v : G[u]){
        if(match[v]==-1 or (!vis[match[v]] and dfs(match[v]))){
            match[v] = u;
            return true;
        }
    }
    return false;
}
void hungary(){
    while(true){
        memset(vis,0,sizeof(vis));
        if(dfs(cur)) cur++;
        else break;
    }
}
int main(){
    ____();
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> pr[i].first;
    for(int i = 1; i <= n; i++) cin >> pr[i].second;
    cin >> q;
    for(int i = 1; i <= q; i++) cin >> Q[i], S.insert(Q[i]);
    for(int i = 1; i <= n; i++) if(!S.count(i)) G[pr[i].first].emplace_back(pr[i].second);
    memset(match,255,sizeof(match));
    for(int i = q; i >= 1; i--){
        hungary();
        ret[i] = cur;
        G[pr[Q[i]].first].emplace_back(pr[Q[i]].second);
    }
    for(int i = 1; i <= q; i++) cout << ret[i] << endl;
    return 0;
}
```
