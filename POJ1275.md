为了方便，把0~23变成1~24
先设置几个变量
1.need[i]表示i时刻需要的收银员的数量
2.emp[i]表示i时刻能够开始工作的收银员的数量
3.s[i]表示到i时刻总共雇佣的收银员的数量
可以得到一些不等式模型:
1. s[i]-s[i-1]<=emp[i]
2. s[i] - s[i-1] >= 0
3. s[i] - s[i-8] >= need[i] (8<=i<=24)

   s[i] + s[24] - s[16+i]>= need[i] (1<=i<8)

其中的emp[i]和need[i]已知的，发现式子中出现了s[24]，这个也就是我们要求的答案，对这个答案进行二分即可
```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int MAXN = 35;
const int INF = 0x3f3f3f3f;
int T,m,need[MAXN],emp[MAXN],inq[MAXN],dist[MAXN];
bool vis[MAXN];
struct Graph{
    int tot,head[MAXN],to[MAXN<<4],nxt[MAXN<<4],cst[MAXN<<4];
    void Init(){ tot = 0; memset(head,255,sizeof(head)); }
    void ADDEDGE(int u, int v, int c){
        tot++;
        to[tot] = v;
        cst[tot] = c;
        nxt[tot] = head[u];
        head[u] = tot;
    }
}G;
bool SPFA(int mid){
    memset(vis,0,sizeof(vis));
    memset(dist,-INF,sizeof(dist));
    memset(inq,0,sizeof(inq));
    queue<int> que;
    que.push(0);
    dist[0] = 0;
    while(!que.empty()){
        int u = que.front();
        que.pop();
        vis[u] = false;
        for(int i = G.head[u]; ~i; i = G.nxt[i]){
            int v = G.to[i];
            int c = G.cst[i];
            if(dist[v]<dist[u]+c){
                dist[v] = dist[u] + c;
                if(!vis[v]){
                    vis[v] = true;
                    if(++inq[v]>24) return false;
                    que.push(v);
                }
            }
        }
    }
    return true;
}
bool check(int mid){
    G.Init();
    G.ADDEDGE(0,24,mid);
    G.ADDEDGE(24,0,-mid);
    for(int i = 1; i <= 24; i++) {
        G.ADDEDGE(i-1,i,0);
        G.ADDEDGE(i,i-1,-emp[i]);
        if(i<8) G.ADDEDGE(i+16,i,need[i]-mid);
        else G.ADDEDGE(i-8,i,need[i]);
    }
    return SPFA(mid);
}
void solve(){
    for(int i = 1; i <= 24; i++) scanf("%d",&need[i]);
    scanf("%d",&m);
    memset(emp,0,sizeof(emp));
    for(int i = 1; i <= m; i++){
        int x; scanf("%d",&x);
        emp[x+1]++;
    }
    int l = 0, r = m;
    while(l<=r){
        int mid = (l+r) >> 1;
        if(check(mid)) r = mid - 1;
        else l = mid + 1;
    }
    if(l>m) printf("No Solution\n");
    else printf("%d\n",l);
}
int main(){
    for(scanf("%d",&T); T; T--) solve();
    return 0;
}
```
