floyd + 二分最大流
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
const int INF = 0x3f3f3f3f;
const int MAXN = 444;
typedef long long int LL;
const LL oo = 0x3f3f3f3f3f3f3f3f;
#define S 0
#define T MAXN - 1
struct EDGE{
    int to,cap,rev;
    EDGE(){}
    EDGE(int _to, int _cap, int _rev){ to = _to; cap = _cap; rev = _rev; }
};
vector<EDGE> G[MAXN];
int n,m,cow[MAXN],cp[MAXN],sum,rk[MAXN],iter[MAXN];
LL dist[MAXN][MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].push_back(EDGE(v,cap,(int)G[v].size()));
    G[v].push_back(EDGE(u,0,(int)G[u].size()-1));
}
bool bfs(){
    memset(iter,0,sizeof(iter));
    memset(rk,0,sizeof(rk));
    rk[S] = 1;
    queue<int> que;
    que.push(S);
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = 0; i < (int)G[u].size(); i++){
            EDGE &e = G[u][i];
            if(!e.cap || rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap || rk[e.to] != rk[u] + 1) continue;
        int d = dfs(e.to,min(f,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
bool Dinic(LL mid){
    for(int i = 0; i <= 2*n; i++) G[i].clear();
    G[T].clear();
    for(int i = 1; i <= n; i++) ADDEDGE(S,i,cow[i]);
    for(int i = 1; i <= n; i++) ADDEDGE(i+n,T,cp[i]);
    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) if(dist[i][j]<=mid) ADDEDGE(i,j+n,INF);
    int flow = 0;
    while(bfs()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow == sum;
}
int main(){
    while(scanf("%d %d",&n,&m)!=EOF){
        sum = 0;
        for(int i = 1; i <= n; i++){
            scanf("%d %d",&cow[i],&cp[i]);
            sum += cow[i];
        }
        memset(dist,0x3f,sizeof(dist));
        for(int i = 1; i <= n; i++) dist[i][i] = 0;
        for(int i = 1; i <= m; i++){
            int u, v, c;
            scanf("%d %d %d",&u,&v,&c);
            dist[u][v] = dist[v][u] = min(dist[u][v],c*1ll);
        }
        for(int k = 1; k <= n; k++) for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++)
            dist[i][j] = dist[j][i] = min(dist[i][j],dist[i][k]+dist[k][j]);
        LL l = 0, r = 0;
        for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) if(dist[i][j]!=oo) r = max(r,dist[i][j]);
        LL tp = r;
        while(l<=r){
            LL mid = (l+r) >> 1;
            if(Dinic(mid)) r = mid - 1;
            else l = mid + 1;
        }
        if(l==tp+1) printf("-1\n");
        else printf("%lld\n",l);
    }
    return 0;
}
```
