二分网络流
```cpp
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 2222;
const int INF = 0x3f3f3f3f;
#define S 0
#define T MAXN-1
struct EDGE{
    int to,cap,rev;
    EDGE(){}
    EDGE(int to, int cap, int rev){
        this->to = to;
        this->cap = cap;
        this->rev = rev;
    }
};
pair<pair<int,int>,int> edge[MAXN<<4];
int p,r,m,pn[MAXN],rn[MAXN],tot,rk[MAXN],iter[MAXN];
vector<EDGE> G[MAXN];
void ADDEDGE(int u, int v, int cap){
    G[u].emplace_back(EDGE(v,cap,(int)G[v].size()));
    G[v].emplace_back(EDGE(u,0,(int)G[u].size()-1));
}
bool BFS(){
    queue<int> que;
    que.push(S);
    memset(rk,0,sizeof(rk));
    memset(iter,0,sizeof(iter));
    rk[S] = 1;
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(auto e : G[u]){
            if(!e.cap||rk[e.to]) continue;
            rk[e.to] = rk[u] + 1;
            que.push(e.to);
        }
    }
    return rk[T]!=0;
}
int dfs(int u, int f){
    if(u==T) return f;
    for(int &i = iter[u]; i < (int)G[u].size(); i++){
        EDGE &e = G[u][i];
        if(!e.cap||rk[e.to]!=rk[u]+1) continue;
        int d = dfs(e.to,min(f,e.cap));
        if(d){
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
        }
    }
    return 0;
}
int Dinic(){
    int flow = 0;
    while(BFS()){
        int d = dfs(S,INF);
        while(d){
            flow += d;
            d = dfs(S,INF);
        }
    }
    return flow;
}
bool check(int mid){
    for(int i = 0; i < MAXN; i++) G[i].clear();
    for(int i = 1; i <= m; i++){
        if(edge[i].second>mid) continue;
        ADDEDGE(edge[i].first.second,edge[i].first.first+r,INF);
    }
    for(int i = 1; i <= p; i++) ADDEDGE(i+r,T,pn[i]);
    for(int i = 1; i <= r; i++) ADDEDGE(S,i,rn[i]);
    return Dinic()==tot;
}
int work(){
    int L = 1, R = 1e6;
    while(L<=R){
        int mid = (L+R) >> 1;
        if(check(mid)) R = mid - 1;
        else L = mid + 1;
    }
    return L>1e6?-1:L;
}
int main(){
    scanf("%d %d %d",&p,&r,&m);
    for(int i = 1; i <= p; i++){
        scanf("%d",&pn[i]);
        tot += pn[i];
    }
    for(int i = 1; i <= r; i++) scanf("%d",&rn[i]);
    for(int i = 1; i <= m; i++) scanf("%d %d %d",&edge[i].first.first,&edge[i].first.second,&edge[i].second);
    printf("%d\n",work());
    return 0;
}
```
