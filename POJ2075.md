最小生成树
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<map>
#include<iomanip>
#include<string>
#include<algorithm>
using namespace std;
double leng;
const int MAXN = 1e6+7;
int n,m,root[MAXN];
map<string,int> mp;
pair<double,pair<int,int> > cab[MAXN];
int findroot(int x){
    if(x!=root[x]) root[x] = findroot(root[x]);
    return root[x];
} 
int main(){
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> leng >> n;
    string name; int ID = 0;
    for(int i = 1; i <= n; i++){
        cin >> name;
        mp.insert(make_pair(name,++ID));
    }
    cin >> m;
    for(int i = 1; i <= m; i++){
        string namea, nameb;
        cin >> namea >> nameb >> cab[i].first;
        cab[i].second.first = mp[namea];
        cab[i].second.second = mp[nameb];
    }
    sort(cab+1,cab+1+m);
    for(int i = 1; i <= n; i++) root[i] = i;
    double res = 0;
    int tot = 1;
    for(int i = 1; i <= m; i++){
        int x = cab[i].second.first;
        int y = cab[i].second.second;
        int fx = findroot(x);
        int fy = findroot(y);
        if(fx==fy) continue;
        res += cab[i].first;
        tot++;
        root[fx] = fy;
    }
    int R = res*10+0.5;
    if(tot!=n||res>leng) cout << "Not enough cable" << endl;
    else cout << "Need " << fixed << setprecision(1) << R/10.0 << " miles of cable" << endl;
    return 0;
}
```
