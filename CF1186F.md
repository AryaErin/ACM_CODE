考虑每个奇数点向虚节点0连一条边，然后可以跑欧拉回路，每个点入度和出度相同，所以进来和出去只要保留一条边即可，但是如果有虚边连着的话，就得要少删一条实边
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 1e6+7;
struct Graph{
    int to[MAXN<<2],nxt[MAXN<<2],head[MAXN],tot;
    bool vert[MAXN<<2];
    Graph(){ memset(head,255,sizeof(head)); tot = 0; }
    void ADDEDGE(int u, int v, bool vt){
        to[tot] = v;
        nxt[tot] = head[u];
        head[u] = tot;
        vert[tot++] = vt;
    }
}G;
int n,m,deg[MAXN],num[MAXN];
bool done[MAXN],vis[MAXN<<2];
void dfs(int u){
    done[u] = true;
    if(deg[u]&1){
        G.ADDEDGE(0,u,true);
        G.ADDEDGE(u,0,true);
    }
    for(int i = G.head[u]; i != -1; i = G.nxt[i]){
        int v = G.to[i];
        if(done[v]) continue;
        dfs(v);
    }
}
vector<pair<int,int> > ret;
vector<pair<pair<int,int>,bool> > vecc;
void euler(int u){
    int tp = ++num[u];
    for(int i = G.head[u]; i != -1; i = G.nxt[i]){
        if(vis[i]) continue;
        vis[i] = vis[i^1] = true;
        G.head[u] = G.nxt[i];
        euler(G.to[i]);
        vecc.emplace_back(make_pair(make_pair(u,G.to[i]),G.vert[i]));
        if(tp!=num[u]) break;
    }
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= m; i++){
        int u, v;
        scanf("%d %d",&u,&v);
        G.ADDEDGE(u,v,false); G.ADDEDGE(v,u,false);
        deg[u]++; deg[v]++;
    }
    for(int i = 1; i <= n; i++){
        if(done[i]) continue;
        G.head[0] = -1;
        dfs(i);
        vecc.clear();
        euler(i);
        bool del = false;
        for(int j = 0; j < (int)vecc.size(); j++, del = !del){
            if(vecc[j].second==true) continue;
            if(vecc[(j-1+vecc.size())%vecc.size()].second==true or vecc[(j+1)%vecc.size()].second==true){
                ret.emplace_back(vecc[j].first);
                del = false;
                continue;
            }
            if(!del) ret.emplace_back(vecc[j].first);
        }
    }
    printf("%d\n",(int)ret.size());
    for(auto p : ret) printf("%d %d\n",p.first,p.second);
    return 0;
}
```
