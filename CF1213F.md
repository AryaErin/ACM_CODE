考虑按两个数列连边，a->b表示a<=b，然后如果ab能够相互到达，那么ab必然相等，建图跑scc即可，最后缩点完必然是一条链，从入度为0的点集开始沿着链往后
字符可以不断变大，也可以相等
```cpp
//#pragma GCC optimize("O3")
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
function<void(void)> ____ = [](){ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);};
const int MAXN = 2e5+7;
int ID[MAXN];
int n,k,dfn[MAXN],low[MAXN],instk[MAXN],idx,num,sccid[MAXN],stk[MAXN],top,pre,now,to[MAXN];
vector<int> scc[MAXN],G[MAXN];
void rebuild(){
    for(int u = 1; u <= n; u++){
        for(int v : G[u]){
            if(sccid[u]==sccid[v]) continue;
            to[sccid[u]] = sccid[v];
        }
    }
}
void tarjan(int u){
    dfn[u] = low[u] = ++idx;
    instk[u] = 1;
    stk[++top] = u;
    for(int v : G[u]){
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u],low[v]);
        }
        else if(instk[v]) low[u] = min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        num++;
        int tp;
        do{
            tp = stk[top--];
            sccid[tp] = num;
            scc[num].emplace_back(tp);
            instk[tp] = false;
        }while(tp!=u);
    }
}
int main(){
    ____();
    cin >> n >> k;
    for(int kase = 1; kase <= 2; kase++){
        cin >> pre;
        for(int i = 1; i < n; i++){
            cin >> now; G[pre].emplace_back(now);
            pre = now;
        }
    }
    for(int i = 1; i < n; i++) if(!dfn[i]) tarjan(i);
    if(num<k){
        cout << "NO" << endl;
        return 0;
    }
    cout << "YES" << endl;
    rebuild();
    int rt = 0;
    for(int i = 1; i <= num; i++) if(!to[i]) rt = i;
    int cur = 0;
    while(true){
        for(int u : scc[rt]) ID[u] = cur;
        if(to[rt]) break;
        cur++; rt = to[rt];
    }
    for(int i = 1; i <= n; i++) ID[i] = min(ID[i],25);
    for(int i = 1; i <= n; i++) cout << (char)(ID[i]+'a');
    cout << endl;
    return 0;
}
```
